# -*- coding: utf-8 -*-
"""implementation3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q9iFhblwtyuzUAPGpH1TVz89ZmGJofc5
"""

# simulation.py

import numpy as np
import pandas as pd
import pymc as pm
from tqdm import tqdm

# 1) Load the full dataset
df = pd.read_csv(r"C:\Users\AV75950\Documents\autorater_predictions_all4.csv")
df['H'] = (df['label'] == 'AD').astype(int)
df['A_class'] = (df['autorater_prediction'] >= 0.5).astype(int)

# Overall pool size and true g
N      = len(df)
g_true = df['H'].mean()
NA1    = int(df['A_class'].sum())

# 2) Chain-rule Estimator (takes prior α, β as arguments)
def chain_rule_estimator(labeled_idx, alpha, beta):
    sub = df.iloc[labeled_idx]
    n1 = int((sub['A_class']==1).sum())
    H1 = int(sub.loc[sub['A_class']==1, 'H'].sum())
    n0 = int((sub['A_class']==0).sum())
    H0 = int(sub.loc[sub['A_class']==0, 'H'].sum())

    with pm.Model() as model:
        θA  = pm.Beta('θA', alpha, beta)
        θH1 = pm.Beta('θH1', alpha, beta)
        θH0 = pm.Beta('θH0', alpha, beta)

        pm.Binomial('obs_A',  N,  θA,  observed=NA1)
        pm.Binomial('obs_H1', n1, θH1, observed=H1)
        pm.Binomial('obs_H0', n0, θH0, observed=H0)

        g = pm.Deterministic('g', θA*θH1 + (1-θA)*θH0)

        idata = pm.sample(
            draws=500, tune=500,
            chains=2, cores=1,
            progressbar=False,
            target_accept=0.9
        )

    g_samples = idata.posterior['g'].values.flatten()
    return g_samples.mean(), np.quantile(g_samples, [0.025, 0.975])

# 3) Naïve Estimator (takes prior α, β as arguments)
def naive_estimator(labeled_idx, alpha, beta):
    sub   = df.iloc[labeled_idx]
    n     = len(sub)
    H_sum = int(sub['H'].sum())
    a, b  = alpha + H_sum, beta + n - H_sum
    samples = np.random.beta(a, b, size=2000)
    return samples.mean(), np.quantile(samples, [0.025, 0.975])

# 4) Difference Estimator (no prior needed)
def difference_estimator(labeled_idx):
    A_bar = df['A_class'].mean()
    resid = df.iloc[labeled_idx]['H'] - df.iloc[labeled_idx]['A_class']
    g_hat = A_bar + resid.mean()

    # Bootstrap CI
    boots = [A_bar + resid.sample(frac=1, replace=True).mean()
             for _ in range(1000)]
    ci = np.quantile(boots, [0.025, 0.975])
    return g_hat, ci

# 5) Simulation settings
nsim        = 50
label_sizes = [10, 20, 40, 80]
priors = [
    {'name':'uniform',  'alpha':1.0,   'beta':1.0},
    {'name':'jeffreys', 'alpha':0.5,   'beta':0.5}
]

all_results = []

for prior in priors:
    pname, α, β = prior['name'], prior['alpha'], prior['beta']
    for nh in label_sizes:
        cov_counts = {'chain':0, 'naive':0, 'diff':0}
        widths     = {'chain':[], 'naive':[], 'diff':[]}

        for _ in tqdm(range(nsim), desc=f"{pname} | labels={nh}"):
            idx = np.random.choice(N, size=nh, replace=False)

            # Chain-rule
            m_c, ci_c = chain_rule_estimator(idx, α, β)
            if ci_c[0] <= g_true <= ci_c[1]:
                cov_counts['chain'] += 1
            widths['chain'].append(ci_c[1] - ci_c[0])

            # Naïve
            m_n, ci_n = naive_estimator(idx, α, β)
            if ci_n[0] <= g_true <= ci_n[1]:
                cov_counts['naive'] += 1
            widths['naive'].append(ci_n[1] - ci_n[0])

            # Difference
            m_d, ci_d = difference_estimator(idx)
            if ci_d[0] <= g_true <= ci_d[1]:
                cov_counts['diff'] += 1
            widths['diff'].append(ci_d[1] - ci_d[0])

        all_results.append({
            'prior':    pname,
            'n_labels': nh,
            'chain_cov':  cov_counts['chain']/nsim,
            'chain_w':    np.mean(widths['chain']),
            'naive_cov':  cov_counts['naive']/nsim,
            'naive_w':    np.mean(widths['naive']),
            'diff_cov':   cov_counts['diff']/nsim,
            'diff_w':     np.mean(widths['diff']),
        })

# 6) Save and print results
res_df = pd.DataFrame(all_results)
res_df.to_csv("simulation_results_prior_sensitivity2.csv", index=False)
print(res_df)

